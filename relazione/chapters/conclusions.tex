\section{Conclusions}
	Our application represents a possible implementation, but not the best one. Due to \direct and, more specifically, Android \direct Framework implementation limits, we were forced to heavly modify our architectural design, resulting in a number of workarounds to simulate a true ad-hoc network communication. We exploited Android \direct framework to create a small network between the various peers and made them communicate via TCP Sockets. This leads to a non scalable simulation, because it's only possible to add new devices at configuration time, and imposes a heavy network load on the super-peer which acts as a server.
	
	Our first aim was to implement a faster and more dynamic mehtod for data transmission: since theoretically the Fast Broadcast algorithm doesn't need a complete network in order to excange messages (it's basically state and connection less), a viable solution was use raw sockets (Data Link level) and implement a light, connectionless protocol over it in order to achieve a real ad-hoc network and a behaviour closer to the theoretical. Unfortunately after several days of coding and research we found that in order to obtain all traffic detectable from the device, promisuous mode was not sufficient, but an even more battery-comsuming mode was needed, usually referred to as monitor mode. Moreover, support for such mode is heavely hardware dependent (not all hardwares support it) and requires direct calls to the network interface device drivers, thus requiring different codes for each device. We reached the conclusion that, for the purposes of this project, this was not acceptable in terms of required time and added complexity (considering that, in addition to the actual raw socket and driver code, exploiting of non documented and unstable Android's native API was neccesary to obtain interprocess communication whit the application, which would obviously be implemented in Java and running in a different process).
