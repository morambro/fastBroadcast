\section{Conclusions}
	Our application represents a possible implementation, but not the best one. Due to \direct and, more specifically, Android \direct Framework implementation limits, we were forced to heavily modify our architectural design, which resulted in a number of workarounds to simulate a true ad-hoc network communication. We exploited Android \direct framework to create a small network between the various peers and made them communicate via TCP Sockets. This leads to a non scalable simulation, because it's only possible to add new devices at configuration time, and imposes a heavy network load on the \textit{super-peer}, which acts as a server.
	Morover, we had to face with the overhead introduced by TCP protocol and Java code execution (grater than $200ms$): this two factors made difficult the verification of application results, and the coordination between devices, expecially douring \textit{Boradcast Phase}.
	Our first aim was to implement a faster and more dynamic method for data transmission: since theoretically the Fast Broadcast algorithm doesn't need a complete network in order to excange messages (it's basically stateless and connectionless), a viable solution was the use of Data Link level raw sockets to implement a light, connectionless protocol in order to achieve a real ad-hoc network and a behaviour closer to the theoretical. Unfortunately, after several days of and research, we found that in order to obtain all traffic detectable from the device, \textit{promiscuous mode} was not sufficient, but an even more battery-comsuming mode was needed, usually referred to as \textit{monitor mode}. Moreover, support for such mode is heavily hardware dependent (not all hardwares support it) and requires direct calls to the network interface device driver, requiring different codes for each device. We concluded that, for the purposes of this project, this was not acceptable in terms of required time and added complexity (considering that, in addition to the things explained before, we needed to exploit some Android's native APIs which were not documented and barely stable in order to obtain inter-process communication with the application).
