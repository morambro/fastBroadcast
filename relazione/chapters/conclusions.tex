\section{Conclusions}
	Our Android application represents a possible implementation, but not the best one. Due to \direct and, more specifically, Android \direct Framework implementation limits, we were forced to heavily modify our architectural design, which resulted in a number of workarounds to simulate a true ad-hoc network communication. We exploited Android \direct framework to create a small network between the various peers and made them communicate via TCP Sockets. This leads to a non scalable simulation, because new devices can only be added at configuration time, and imposes a heavy network load on the peer which acts as a server.
	Moreover, the overhead introduced by the TCP protocol and the execution under the Java Virtual Machine resulted in a difficult validation of the the application results, and added a significant amount of complexity to the coordination of different devices.
	Our first aim was to implement a faster and more dynamic method for data transmission: since in general Vehicolar algorithms do not need a complete network in order to exchange messages (they are basically stateless and connectionless), a viable solution was the use of Data Link level raw sockets to implement a light, connectionless protocol in order to achieve a real ad-hoc network and a behaviour closer to the theoretical. We implemented low level Raw Sockets working on Fedora Operating Systems, but we could not use the developed library on Android devices: the reduced Linux Kernel in Android, lacks of some essential modules. However, we built a desktop application, wich results in higher performances and scalability compared to the Android application. Raw Sockets reduce also connection overhead working at MAC layer level.
	%Unfortunately, after several days of coding and research, we found that in order to obtain all traffic detectable from a device \textit{promiscuous mode} was not sufficient, but an even more battery-comsuming mode was needed, usually referred to as \textit{monitor mode}. Moreover, support for such mode is heavily hardware dependent (not all hardwares support it) and requires direct calls to the network interface device driver, requiring different codes for each device. We concluded that, for the purposes of this project, this was not acceptable in terms of required time and added complexity (considering that, in addition to the forking needed by specific device drivers, the use of unstable and undocumented Android APIs was needed to achieve inter-process communication between the native code, which would be running with root privileges, and the standard Java application).

