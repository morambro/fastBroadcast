\section{Implementation}
\label{sec:implementation}

Our application is structured in different units, each performing a specific function. There is a single Activity class\footnote{Entry point of our Android application. For other information on Activity class visit \url{http://developer.android.com/guide/components/activities.html}}, called \ttt{FastBroadcastActivity}, which at application startup performs graphical initializations, creates the application controller, represented by class \ttt{AppController}, which implements \ttt{IAppController} interface, and initializes broadcast receiver\footnote{For information abour what a broadcast receiver is, visit \url{http://developer.android.com/reference/android/content/BroadcastReceiver.html}}, represented by \ttt{FastBroadcastReceiver} class.

\subsection{Helper}
Packege \ttt{it.unipd.fast.broadcast.helper} contains an helper class \ttt{XMLParser}. This class provides static methods to manage XML strings and extracting information from them.

\subsection{Location}

\subsection{Wi-fi Connection}
The component which manages Wi-fi connection is contained in the package \begin{center}\ttt{it.unipd.fast.broadcast.wifi\_connection}\end{center} composed by four subpackages:
	\\
	\subsubsection{\ttt{message}}
	This package contains \ttt{IMessage} astract class, representing a generic message. It offers methods to create and add content to the message, and to retrieve easily message type, recipient and sender identificators, and content (as a \ttt{Map}). It also offers two static methods \ttt{String concatContent(String ...contents)} which concatenates strings in \ttt{contents} array, and \ttt{String[] splitContent(String s)} which splits the given string based on a static separator \ttt{CHAR\_SEPARATOR}. 
	We used xml messages exchange, and they are represented by \ttt{XMLMessage} subclass, that implements \ttt{IMessage} abstract methods to build xml string and extract information from them. To facilitate message building we introduced a singleton class \ttt{MessageBuilder}; it provides few methods to create \ttt{XMLMessage} instances.
	\hfill\\
	\subsubsection{\ttt{receiver}}
	This package contains classes used to listen to broadcast intents generated by Android operating system representing Wi-fi events, and to receive data from other devices.
	The first operation is done by previously mentioned \ttt{FastBroadcastReceiver} class. This class extends \ttt{android.content.BroadcastReceiver} class. The method \ttt{void onReceive(final Context context, Intent intent)} is called when an intent is broadcasted, so in our redefinition it discrimnates from different intent types:
	\begin{itemize}
		\item WIFI\_P2P\_STATE\_CHANGED\_ACTION \hfill \\
		indicates whether device's Wi-fi p2p funcion is enabled or not; if don't, a dialog is shown to the user, telling him to enable it, otherwise peers discovering is requested.
		\item WIFI\_P2P\_PEERS\_CHANGED\_ACTION \hfill \\
		is generated when Wi-fi device finds new peers (is executed after requesting peers discovering). If this intent is received, peers list is requested to \direct framework.
		\item WIFI\_P2P\_CONNECTION\_CHANGED\_ACTION \hfill \\
		is generated when a connection or a disconnection occours. If curent device is connected it means he belongs to a \direct group, so is asked to \direct framework for connection information.
		\item WIFI\_P2P\_THIS\_DEVICE\_CHANGED\_ACTION \hfill \\
		indicates Wi-fi state changed, so is asked \direct framework to start peers discovering.		
	\end{itemize}

All the requests from \direct framework are asynchronous, like Intent broadcasting; listeners are required to let the application be notified, so they are passed to \ttt{BroadcastReceiver}'s contructor by \ttt{AppController}.
	
	The second task is achieved by \ttt{DataReceiverService} which implements \ttt{IDataReceiverService} and \ttt{Runnable} interfaces, and extends \ttt{android.app.Service}. This class represents an Android service which listens on port 8888 for incoming TCP connection. When a TCP connection is opened, it handles it on a separate thread, to enable multiple requests handling. When a message arrives as a string, is converted to an \ttt{XMLMessage} instance using \ttt{MessageBuilder}, and passed to all registered handlers (instances of \ttt{IDataCollectionHandler} interface); hadlers registration is made with \ttt{registerHandler} method.
	\ttt{CollectionHandler} class is a specific \ttt{IDataCollectionHandler} implementation. His method \ttt{onDataCollected(IMessage message, String hostIp)} depending on received message's type calls different \ttt{IAppController} operations. Parameter \ttt{hostIp} contains the string representation of sender IP address: this information is used when a \textbf{Ping} message arrives to update peers addresses map.
	
	\\
	\subsubsection{\ttt{connectionmanager}}
	This package's classes are used to handle connection information, requested to \direct framework. These information are given in the form of a \ttt{android.net.wifi.p2p.WifiP2pInfo} instance; this class provides methods to obtain group owner's IP address, and to know if the current device is the group owner: this information is very important because depending whether the device is group owner or not, different operation has to be done. Class \ttt{ConnectionInfoManager} implementing \ttt{IConnectionInfoManager} manage this situation: it is passed as an handler to \direct framework, which calls \ttt{onConnectionInfoAvailable(WifiP2pInfo info)} asynchronously. 
	If the current device is not a group owner, it have to send a \tetbf{Ping} message to the owner, including his MAC address in it.
	These operation are done on a separate thread, to prevent application stops on blocking operations.
	
	\\
	\subsubsection{\ttt{transmissionmanager}}
	This package contains classes used to send out messages to other devices. \ttt{ITransmissionManager} interface provides methods to send a message to a single device (based on a generic String id) or to a devices list. His implementation class \ttt{TcpTransmissionManager} use TCP Sockets to send out messages, performing it on a separate thread. To obtain a \ttt{TcpTransmissionManager} instance, is provided the sigleton class \ttt{TransmissionManagerFactory}.
	
\subsection{Protocol implementation}

