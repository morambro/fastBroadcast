\section{Implementation}
\label{sec:implementation}

Our application is structured in different modules, each performing a specific task.
%%
% Le note a piè di pagina con i link alla documentazione di android sulle activity se possibile
% spostala in bibliografia
%%

Throughout the classes' hierarchy there's just one \textit{Activity}\ref{activity}; it's called \ttt{FastBroadcastActivity} and —at application startup— performs graphical initializations and creates the application controller. The Application controller is represented by \ttt{AppController} class which provides the interface \ttt{IAPPConttoller}; it creates a new \textit{broadcast receiver}\ref{broadcast_receiver}, which is an instance of \ttt{FastBroadcastReceiver} class.

%**************************************************************** HELPER ************************************************
\subsection{Helper}
The package \ttt{it.unipd.fast.broadcast.helper} contains an helper class \ttt{XMLParser}. This class provides static methods to manage XML strings and extract information from them.

%************************************************************** LOCATION ************************************************
\subsection{Location}

The package \ttt{it.unipd.fast.broadcast.location} contains \textit{Services} used to request and menage location updates, and a \ttt{MockLocationService} class used to provide location data to the application from a custom text file.

%*********************************************************** WI-FI CONNECTION ********************************************
\subsection{Wi-Fi Connection}
The component which manages Wi-Fi connection is contained in the package
\begin{center}
	\ttt{it.unipd.fast.broadcast.wifi\_connection}
\end{center} 
It is composed by four subpackages:
	\\
	\subsubsection{\ttt{message}}
	This package contains the \ttt{IMessage} abstract class, which represents a generic message. It offers methods to create a message and to add content to it. This class has the methods to easily retrieve the message type, the recipient, the sender identificators and the content (as a reference to a \ttt{java.util.Map}'s subclass instance). It also offers two static methods:
	\begin{itemize}
		\item \ttt{String concatContent(String[] content)} which returns a string obtained by concatenating the strings contained in the \ttt{content} array.
		\item \ttt{String[] splitContent(String s)} which splits the given string based on the static separator \ttt{CHAR\_SEPARATOR}. 
	\end{itemize}
	In our implementation, we exchange messages encoded as XML. They are represented by \ttt{XMLMessage} subclass, which implements \ttt{IMessage}'s abstract methods to build the XML string and to extract informations from them. To facilitate message building we introduced a singleton class \ttt{MessageBuilder}, which provides a few methods to create \ttt{XMLMessage} instances.
	\hfill\\
	\subsubsection{\ttt{receiver}}
	This package contains classes used:
	\begin{itemize}
		\item to listen for broadcast Wi-Fi \texit{Intents} \ttt{Intent}s\ref{intent} generated by the Android operating system;
		\item to receive data from other devices.
	\end{itemize}
	
	The first operation is performed by the previously mentioned \ttt{FastBroadcastReceiver} class which extends \ttt{android.content.BroadcastReceiver} class. The method \ttt{void onReceive(final Context context, Intent intent)} is called when an \ttt{Intent} is broadcasted; in our implementation, it performs different operations depending on the \ttt{intent}'s type:
	\begin{itemize}
		\item WIFI\_P2P\_STATE\_CHANGED\_ACTION \hfill \\
		this type indicates whether a device's WI-FI P2P funcion is enabled or not; if it's enabled, peer discovering is started using \direct APIs, otherwise a dialog is shown to the user, telling him to enable it.
		\item WIFI\_P2P\_PEERS\_CHANGED\_ACTION \hfill \\
		an intent with this type is generated when the Wi-Fi device finds new peers (this obviously happens only after the peer discovering phase). If this \ttt{Intent} is received, the peers list is requested to the \direct framework.
		\item WIFI\_P2P\_CONNECTION\_CHANGED\_ACTION \hfill \\
		an intent with this type is generated when a connection or a disconnection occurs. If the current device is connected it means that it belongs to a \direct group, so informations about the group are requested to the \direct framework.
		\item WIFI\_P2P\_THIS\_DEVICE\_CHANGED\_ACTION \hfill \\
		%% questa frase non mi piace :(
		this type indicates Wi-Fi state changes; when this \ttt{Intent} is received, peer discovering should start again.
	\end{itemize}

All the requests coming from the \direct framework are \textit{asynchronous}, like \ttt{Intent} broadcasting; listeners are required so that the application can be notified. These listeners are passed to \ttt{BroadcastReceiver}'s contructor by \ttt{AppController}.
	
	The second task is achieved by \ttt{DataReceiverService} which implements \ttt{IDataReceiverService} and \ttt{Runnable} interfaces, and extends \ttt{android.app.Service}. This class represents an Android service which listens on port 8888 for incoming TCP connections. When a TCP connection is received, the class handles it on a separate thread, to enable multiple requests handling. When a message arrives as a string, is converted to an \ttt{XMLMessage} instance using \ttt{MessageBuilder}, and passed to all the registered handlers (instances of \ttt{IDataCollectionHandler} interface); the method \ttt{registerHandler} is used to register handlers.
	\ttt{CollectionHandler} class is a specific \ttt{IDataCollectionHandler} implementation. Its method \ttt{onDataCollected(IMessage message, String hostIp)} calls different \ttt{IAppController} operations, depending on the type of the received. The parameter \ttt{hostIp} contains the string representation of the sender IP address: this information is used when a \textbf{Ping} message arrives to update peer's address map.
	\\
	\subsubsection{\ttt{connectionmanager}}
	Classes in this package are used to handle connection informations. Informations are requested to the \direct framework. These informations are given in the form of \ttt{android.net.wifi.p2p.WifiP2pInfo} instances. This class provides methods to obtain group owner's IP address, and to know if the current device is the group owner: this information is very important because depending whether the device is \textit{group owner} or not, different operations have to be done. The class \ttt{ConnectionInfoManager}, which implements \ttt{IConnectionInfoManager} manages this situation: it is passed as an handler to the \direct framework, which calls \ttt{onConnectionInfoAvailable(WifiP2pInfo info)} asynchronously. 
	If the current device is not the \textit{group owner}, it has to send a \textbf{Ping} message to it, including his MAC address.
	These operations are done on a separate thread, to prevent application freezes on blocking operations.
	\\
	\subsubsection{\ttt{transmissionmanager}}
	This package contains classes used to send messages to other devices. The \ttt{ITransmissionManager} interface provides methods to send a message to a single device (based on a generic \ttt{String} id) or to a devices list. It's implemented by the class \ttt{TcpTransmissionManager}, which uses TCP Sockets to send messages, doing this on a separate thread. The sigleton class \ttt{TransmissionManagerFactory} can be used to obtain a \ttt{TcpTransmissionManager} instance.

%**********************************************************PROTOCOL ************************************************
\subsection{Protocol implementation}

% perché questo è in center?
% communicate with this component; this component == protocol_implementation?
% se non è così, esplicita che io ho capito questo
Package 
\begin{center}
\ttt{it.unipd.fast.broadcast.\\protocol\_implementation}\end{center} 
implements the Fast Broadcast protocol. It provides an interface \ttt{ICommunicationHandler} used by the controller to communicate with this component. The class \ttt{FastBroadcastService} realizes the protocol. It indeed implements \ttt{ICommunicationHandler} interface and extends \ttt{android.app.Service}. \ttt{FastBroadcastService} has two inner private classes:
\begin{itemize}
	\item \ttt{HelloMessageSender}, a \ttt{java.util.TimerTask} subclass which realizes the task of sending \textbf{Hello} messages. This task is scheduled at a fixed time $T$: it waits for a random time between $0$ and $T$ and if no other \textbf{Hello} messages were sent (it checks whether \ttt{helloMessageArrived} is \ttt{true} or not), it broadcasts it.
	\item \ttt{MessageForwarder}, a thread class used to perform message forwarding (\textit{Broadcast phase}). It has a synchronized message queue on which this thread waits until \ttt{IMessage} instances are added. When a message arrives it calculates \textit{contention window} and waits a random time; after the timeout fires, it forwards the message (if no one else did it first). After forwarding the message, it calls \ttt{doOnForwarded} method, to update devices positions.
\end{itemize} 

The method \ttt{helloMessageReceived(IMessage message)} is called by the application controller when an \textbf{Hello} message arrives. It sets \ttt{helloMessageArrived} field to \ttt{true} and performs range estimation on a separate thread.

%******************************************************** CONTROLLER ************************************************
\subsection{Controller}

Class \ttt{AppController} implements \ttt{IAppController} interface and is responsable for application modules coordination. It defines some methods which are callable from the application activity and from other classes to handle to asynchronous events. This class defines several inner classes, each implementing \ttt{android.content.ServiceConnection}. These inner classes are used to handle the asynchronous creation of some Android services:
	\begin{itemize}
		\item \ttt{LocServiceConnection} is used to create the localization service. When the service is created, a \ttt{LocationListener} implementation is setted, to receive updates about location changes.  
		\item \ttt{DataServiceConnection} is used to create \ttt{DataReceiverService}. On service creation, a \ttt{CollectionHandler} instance is setted.
		\item \ttt{FastBroadcastServiceConnection} is used to create \ttt{FastBroadcastService}. When this service is created, the current location and an handler implementation are setted.   
		% l'handler cosa gestisce? potresti dirlo
	\end{itemize}  
	
The application controller communicates with other modules using the interfaces they provide, or using listener objects when expecting asynchronous results.
